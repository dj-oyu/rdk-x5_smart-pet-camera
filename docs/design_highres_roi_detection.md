# 高解像度入力 + ROI 検出設計

## 目的

1. 高解像度入力により小物体の検出精度を向上
2. ROI クロップで縮小ロスを回避
3. オーバーヘッド最適化で実効スループット向上

---

## 現状分析

### パイプライン (Phase 1 完了時点)

```
1920x1080 → VSE Ch1 → 640x360 → letterbox → 640x640 → BPU → 後処理
            (3倍縮小)            (黒帯追加)
```

### 実測タイミング (yolo11n)

| 処理 | 時間 | 備考 |
|------|------|------|
| zero-copy import | ~2ms | hb_mem_import_graph_buf |
| 前処理 | ~1ms | letterbox (黒帯追加) |
| **BPU推論** | **~9ms** | yolo11n 本体 |
| 後処理 | ~5-8ms | DFL decode + NMS |
| **合計** | **16-20ms** | 実測値 |

### 問題点

1. **縮小ロス**: 1920→640 で3倍縮小、小物体が検出困難
2. **黒帯の無駄**: 640x640 の 44% が無効領域
3. **後処理が重い**: scipy.softmax, per-class NMS ループ

---

## 新アーキテクチャ

### A. 高解像度 ROI クロップ方式

```
1920x1080 → VSE Ch1 → 1280x720 or 1920x1080 (フル)
                          ↓
              ROI クロップ (640x640 × N領域)
                          ↓
                    BPU 推論 (1領域/フレーム)
                          ↓
                    座標変換・統合
```

### B. ROI 分割パターン

#### 1280x720 の場合 (2x1 = 2 ROI)

```
+---------------+---------------+
|               |               |
|   ROI 0       |   ROI 1       |
|   640x640     |   640x640     |
|   (0,40)      |   (640,40)    |
|               |               |
+---------------+---------------+
         1280x720
```

- 80px オーバーラップ (720 - 640 = 80, 上下40px)
- 2フレームで全域カバー

#### 1920x1080 の場合 (3x2 = 6 ROI, オーバーラップあり)

```
+--------+--------+--------+
| ROI 0  | ROI 1  | ROI 2  |
| 640x640| 640x640| 640x640|
+--------+--------+--------+
| ROI 3  | ROI 4  | ROI 5  |
| 640x640| 640x640| 640x640|
+--------+--------+--------+
         1920x1080
```

- 水平: (1920-640)/(3-1) = 640px ステップ
- 垂直: (1080-640)/(2-1) = 440px ステップ
- 6フレームで全域カバー

### C. ROI 巡回戦略

| 戦略 | 説明 | 遅延 | 適用場面 |
|------|------|------|----------|
| ラウンドロビン | 順番に巡回 | Nフレーム | 全域監視 |
| 重み付き巡回 | 検出多い領域を頻繁に | 可変 | 活動領域追跡 |
| 適応的フォーカス | 前回検出位置周辺を優先 | 1-2フレーム | 追跡重視 |

---

## オーバーヘッド最適化

### 1. 後処理の高速化

#### a. scipy.softmax → numpy 実装

```python
# Before (scipy)
from scipy.special import softmax
result = softmax(x, axis=2)

# After (numpy, ~2x faster)
def fast_softmax(x, axis=-1):
    e_x = np.exp(x - np.max(x, axis=axis, keepdims=True))
    return e_x / np.sum(e_x, axis=axis, keepdims=True)
```

#### b. DFL デコードのベクトル化

```python
# 現在: ループ内で reshape + sum
# 最適化: 事前に weights を broadcast 形式で保持
```

#### c. NMS の一括処理

```python
# 現在: クラス別ループ
for class_id in unique_classes:
    indices = cv2.dnn.NMSBoxes(...)

# 最適化: batched NMS (torchvision.ops.batched_nms 相当)
```

### 2. メモリアクセス最適化

- ROI クロップは numpy view (コピー不要)
- 連続メモリアクセスパターンの維持

### 3. 不要な処理の削除

- CLAHE: 昼間は完全スキップ (現在も条件分岐あり)
- 座標変換: 整数演算に統一

---

## 実装計画

### Phase 2-1: VSE 高解像度化 ✅ 完了

1. `vio_lowlevel.c`: Ch1 を 1280x720 に変更 ✅
2. `camera_pipeline.c`: plane_size の動的対応確認 ✅
3. `yolo_detector.py`: 高解像度入力のリサイズパス追加 ✅

### Phase 2-2: 後処理最適化 ✅ 完了

1. `yolo_detector.py`: scipy.softmax → numpy 実装 ✅
2. DFL デコードのベクトル化 (既存実装で十分)
3. タイミング計測で効果検証 ✅

### Phase 2-3: ROI クロップ実装 ✅ 完了

1. `yolo_detector.py`: `detect_nv12_roi()` メソッド追加 ✅
2. `get_roi_regions()`: ROI 座標計算ユーティリティ ✅
3. `_crop_nv12_roi()`: NV12 クロップ実装 ✅
4. 座標変換 (ROI → 元画像) ✅

### Phase 2-4: ROI 巡回ロジック ✅ 完了

1. `yolo_detector_daemon.py`: ROI インデックス管理 ✅
2. ラウンドロビン巡回 ✅
3. `--no-roi` フラグでROIモード無効化 ✅
4. 検出結果の時間的統合 (Phase 3 へ延期)
5. フレーム間追跡 (Phase 4 へ延期)

---

## 後処理統合オプション (将来検討)

現状は逐次処理方式を採用。以下は将来の改善候補。

### 現状: 逐次処理 (採用中)

```
Frame N:   ROI 0 → 推論 → 後処理 → 検出結果
Frame N+1: ROI 1 → 推論 → 後処理 → 検出結果
```

- **メリット**: 実装シンプル、低レイテンシ (1推論分)
- **デメリット**: ROI境界の重複検出が各フレームで個別出力

### 案A: 同一フレーム全ROI処理 + 統合NMS

```
Frame N: ROI 0 → 推論 ─┐
         ROI 1 → 推論 ─┴→ 統合NMS → 検出結果
```

- **メリット**: 1フレームで全域カバー、境界重複を1回のNMSで除去
- **デメリット**: レイテンシ増加 (推論2回分)、BPU同期APIのため並列化不可
- **実装**: `detect_nv12_multi_roi()` メソッド追加

### 案B: 時間統合 + 遅延NMS

```
Frame N:   ROI 0 → 推論 → キャッシュ[0]
Frame N+1: ROI 1 → 推論 → キャッシュ[1] → 統合NMS → 出力
```

- **メリット**: フレームレート維持、境界重複を事後除去
- **デメリット**: 検出結果が1フレーム遅延、キャッシュ管理が必要
- **実装**: 検出結果リングバッファ + ROI巡回完了時にNMS

### 案C: 適応的ROI (動体追跡連動)

```
検出あり → 検出位置周辺にROIフォーカス
検出なし → ラウンドロビン巡回
```

- **メリット**: 追跡中は高精度・低遅延
- **デメリット**: 実装複雑、初回検出は巡回頼み
- **実装**: 前フレーム検出位置からROI中心を動的計算

### 判断基準

| 方式 | レイテンシ | 全域カバー | 重複除去 | 実装難度 |
|------|-----------|-----------|---------|---------|
| 逐次処理 | 低 | Nフレーム | なし | 低 |
| 案A | 中 | 1フレーム | あり | 中 |
| 案B | 低 | Nフレーム | あり | 中 |
| 案C | 可変 | 可変 | 部分的 | 高 |

---

## 期待効果

| 指標 | 現状 | 目標 |
|------|------|------|
| 入力解像度 | 640x360 | 1280x720 |
| 有効ピクセル率 | 56% (黒帯あり) | 100% (ROI) |
| 全域カバー周期 | 1フレーム | 2フレーム |
| 推論時間 | 16-20ms | 12-15ms (最適化後) |
| 小物体検出 | 3倍縮小で困難 | 2倍縮小で改善 |

---

## 判断ポイント

1. **VSE 解像度**: 1280x720 (2 ROI) vs 1920x1080 (6 ROI)
2. **ROI 巡回**: ラウンドロビン vs 適応的
3. **後処理最適化**: どこまで追求するか
